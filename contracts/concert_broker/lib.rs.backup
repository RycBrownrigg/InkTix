#![cfg_attr(not(feature = "std"), no_std, no_main)]

/// InkTix Concert Broker - Minimal Working Version (Clippy-Safe)

#[ink::contract]
mod concert_broker {
    use ink::storage::Mapping;
    use ink::prelude::string::String;

    #[ink(storage)]
    pub struct ConcertBroker {
        events: Mapping<u32, ConcertEvent>,
        next_event_id: u32,
        tickets: Mapping<u64, ConcertTicket>,
        next_ticket_id: u64,
        owner: AccountId,
        artists: Mapping<u32, Artist>,
        next_artist_id: u32,
    }

    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout))]
    pub struct ConcertEvent {
        pub id: u32,
        pub name: String,
        pub date: u64,
        pub capacity: u32,
        pub sold_tickets: u32,
        pub base_price: Balance,
        pub active: bool,
        pub artist_id: u32,
    }

    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout))]
    pub struct ConcertTicket {
        pub id: u64,
        pub event_id: u32,
        pub owner: AccountId,
        pub purchase_price: Balance,
        pub purchase_date: u64,
    }

    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout))]
    pub struct Artist {
        pub id: u32,
        pub name: String,
        pub verified: bool,
    }

    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum Error {
        EventNotFound,
        Unauthorized,
        InsufficientPayment,
        ArtistNotFound,
        EventIdOverflow,
        TicketIdOverflow,
    }

    impl ConcertBroker {
        #[ink(constructor)]
        pub fn new() -> Self {
            Self {
                events: Mapping::new(),
                next_event_id: 1,
                tickets: Mapping::new(),
                next_ticket_id: 1,
                owner: Self::env().caller(),
                artists: Mapping::new(),
                next_artist_id: 1,
            }
        }

        #[ink(message)]
        pub fn register_artist(&mut self, name: String) -> Result<u32, Error> {
            let caller = self.env().caller();
            if caller != self.owner {
                return Err(Error::Unauthorized);
            }

            let artist_id = self.next_artist_id;
            self.next_artist_id = self.next_artist_id
                .checked_add(1)
                .ok_or(Error::EventIdOverflow)?;

            let artist = Artist {
                id: artist_id,
                name,
                verified: true,
            };

            self.artists.insert(artist_id, &artist);
            Ok(artist_id)
        }

        #[ink(message)]
        pub fn create_concert_event(
            &mut self,
            name: String,
            date: u64,
            capacity: u32,
            base_price: Balance,
            artist_id: u32,
        ) -> Result<u32, Error> {
            let caller = self.env().caller();
            if caller != self.owner {
                return Err(Error::Unauthorized);
            }

            let _artist = self.artists.get(artist_id).ok_or(Error::ArtistNotFound)?;

            let event_id = self.next_event_id;
            self.next_event_id = self.next_event_id
                .checked_add(1)
                .ok_or(Error::EventIdOverflow)?;

            let event = ConcertEvent {
                id: event_id,
                name,
                date,
                capacity,
                sold_tickets: 0,
                base_price,
                active: true,
                artist_id,
            };

            self.events.insert(event_id, &event);
            Ok(event_id)
        }

        #[ink(message, payable)]
        pub fn purchase_ticket(&mut self, event_id: u32) -> Result<u64, Error> {
            let buyer = self.env().caller();
            let payment = self.env().transferred_value();

            let mut event = self.events.get(event_id).ok_or(Error::EventNotFound)?;
            
            if payment < event.base_price {
                return Err(Error::InsufficientPayment);
            }

            let ticket_id = self.next_ticket_id;
            self.next_ticket_id = self.next_ticket_id
                .checked_add(1)
                .ok_or(Error::TicketIdOverflow)?;

            let ticket = ConcertTicket {
                id: ticket_id,
                event_id,
                owner: buyer,
                purchase_price: payment,
                purchase_date: self.env().block_timestamp(),
            };

            self.tickets.insert(ticket_id, &ticket);

            event.sold_tickets = event.sold_tickets.saturating_add(1);
            self.events.insert(event_id, &event);

            Ok(ticket_id)
        }

        #[ink(message)]
        pub fn get_artist(&self, artist_id: u32) -> Option<Artist> {
            self.artists.get(artist_id)
        }

        #[ink(message)]
        pub fn get_event(&self, event_id: u32) -> Option<ConcertEvent> {
            self.events.get(event_id)
        }

        #[ink(message)]
        pub fn get_ticket(&self, ticket_id: u64) -> Option<ConcertTicket> {
            self.tickets.get(ticket_id)
        }

        #[ink(message)]
        pub fn get_owner(&self) -> AccountId {
            self.owner
        }
    }

    impl Default for ConcertBroker {
        fn default() -> Self {
            Self::new()
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[ink::test]
        fn new_works() {
            let contract = ConcertBroker::new();
            assert_eq!(contract.next_event_id, 1);
            assert_eq!(contract.next_artist_id, 1);
        }

        #[ink::test]
        fn register_artist_works() {
            let mut contract = ConcertBroker::new();
            
            let artist_id = contract.register_artist("Taylor Swift".to_string()).unwrap();
            assert_eq!(artist_id, 1);
            
            let artist = contract.get_artist(artist_id).unwrap();
            assert_eq!(artist.name, "Taylor Swift");
            assert!(artist.verified);
        }

        #[ink::test]
        fn create_event_works() {
            let mut contract = ConcertBroker::new();
            
            let artist_id = contract.register_artist("Drake".to_string()).unwrap();
            
            let event_id = contract.create_concert_event(
                "Drake Concert".to_string(),
                1704067200000,
                10000,
                100_000_000_000_000,
                artist_id,
            ).unwrap();
            
            assert_eq!(event_id, 1);
            
            let event = contract.get_event(event_id).unwrap();
            assert_eq!(event.name, "Drake Concert");
            assert_eq!(event.artist_id, artist_id);
        }
    }
}